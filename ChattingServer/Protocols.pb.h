// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocols.proto

#ifndef PROTOBUF_Protocols_2eproto__INCLUDED
#define PROTOBUF_Protocols_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Protocols_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsUser_LoginImpl();
void InitDefaultsUser_Login();
void InitDefaultsEnter_ChannelImpl();
void InitDefaultsEnter_Channel();
void InitDefaultsChange_ChannelImpl();
void InitDefaultsChange_Channel();
void InitDefaultsChannel_ChattingImpl();
void InitDefaultsChannel_Chatting();
void InitDefaultsCreate_RoomImpl();
void InitDefaultsCreate_Room();
void InitDefaultsRoom_ChattingImpl();
void InitDefaultsRoom_Chatting();
void InitDefaultsEnter_RoomImpl();
void InitDefaultsEnter_Room();
void InitDefaultsLeave_RoomImpl();
void InitDefaultsLeave_Room();
void InitDefaultsNotify_Exist_RoomImpl();
void InitDefaultsNotify_Exist_Room();
void InitDefaultsNotify_Enter_RoomImpl();
void InitDefaultsNotify_Enter_Room();
void InitDefaultsNotify_Leave_RoomImpl();
void InitDefaultsNotify_Leave_Room();
void InitDefaultsRoom_ListImpl();
void InitDefaultsRoom_List();
inline void InitDefaults() {
  InitDefaultsUser_Login();
  InitDefaultsEnter_Channel();
  InitDefaultsChange_Channel();
  InitDefaultsChannel_Chatting();
  InitDefaultsCreate_Room();
  InitDefaultsRoom_Chatting();
  InitDefaultsEnter_Room();
  InitDefaultsLeave_Room();
  InitDefaultsNotify_Exist_Room();
  InitDefaultsNotify_Enter_Room();
  InitDefaultsNotify_Leave_Room();
  InitDefaultsRoom_List();
}
}  // namespace protobuf_Protocols_2eproto
namespace Protocols {
class Change_Channel;
class Change_ChannelDefaultTypeInternal;
extern Change_ChannelDefaultTypeInternal _Change_Channel_default_instance_;
class Channel_Chatting;
class Channel_ChattingDefaultTypeInternal;
extern Channel_ChattingDefaultTypeInternal _Channel_Chatting_default_instance_;
class Create_Room;
class Create_RoomDefaultTypeInternal;
extern Create_RoomDefaultTypeInternal _Create_Room_default_instance_;
class Enter_Channel;
class Enter_ChannelDefaultTypeInternal;
extern Enter_ChannelDefaultTypeInternal _Enter_Channel_default_instance_;
class Enter_Room;
class Enter_RoomDefaultTypeInternal;
extern Enter_RoomDefaultTypeInternal _Enter_Room_default_instance_;
class Leave_Room;
class Leave_RoomDefaultTypeInternal;
extern Leave_RoomDefaultTypeInternal _Leave_Room_default_instance_;
class Notify_Enter_Room;
class Notify_Enter_RoomDefaultTypeInternal;
extern Notify_Enter_RoomDefaultTypeInternal _Notify_Enter_Room_default_instance_;
class Notify_Exist_Room;
class Notify_Exist_RoomDefaultTypeInternal;
extern Notify_Exist_RoomDefaultTypeInternal _Notify_Exist_Room_default_instance_;
class Notify_Leave_Room;
class Notify_Leave_RoomDefaultTypeInternal;
extern Notify_Leave_RoomDefaultTypeInternal _Notify_Leave_Room_default_instance_;
class Room_Chatting;
class Room_ChattingDefaultTypeInternal;
extern Room_ChattingDefaultTypeInternal _Room_Chatting_default_instance_;
class Room_List;
class Room_ListDefaultTypeInternal;
extern Room_ListDefaultTypeInternal _Room_List_default_instance_;
class User_Login;
class User_LoginDefaultTypeInternal;
extern User_LoginDefaultTypeInternal _User_Login_default_instance_;
}  // namespace Protocols
namespace Protocols {

enum PacketType {
  ENTER_CHANNEL = 1,
  USER_LOGIN = 2,
  CREATE_ROOM = 3,
  CHANGE_CHANNEL = 4,
  NOTIFY_ENTER_ROOM = 5,
  NOTIFY_LEAVE_ROOM = 6,
  NOTIFY_EXIST_ROOM = 7,
  ROOM_CHATTING = 8,
  ENTER_ROOM = 9,
  ROOM_LIST = 10,
  CHANNEL_CHATTING = 11,
  LEAVE_ROOM = 12
};
bool PacketType_IsValid(int value);
const PacketType PacketType_MIN = ENTER_CHANNEL;
const PacketType PacketType_MAX = LEAVE_ROOM;
const int PacketType_ARRAYSIZE = PacketType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketType_descriptor();
inline const ::std::string& PacketType_Name(PacketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketType_descriptor(), value);
}
inline bool PacketType_Parse(
    const ::std::string& name, PacketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketType>(
    PacketType_descriptor(), name, value);
}
// ===================================================================

class User_Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.User_Login) */ {
 public:
  User_Login();
  virtual ~User_Login();

  User_Login(const User_Login& from);

  inline User_Login& operator=(const User_Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User_Login(User_Login&& from) noexcept
    : User_Login() {
    *this = ::std::move(from);
  }

  inline User_Login& operator=(User_Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User_Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User_Login* internal_default_instance() {
    return reinterpret_cast<const User_Login*>(
               &_User_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(User_Login* other);
  friend void swap(User_Login& a, User_Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User_Login* New() const PROTOBUF_FINAL { return New(NULL); }

  User_Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const User_Login& from);
  void MergeFrom(const User_Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(User_Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional int32 user_pid = 1;
  bool has_user_pid() const;
  void clear_user_pid();
  static const int kUserPidFieldNumber = 1;
  ::google::protobuf::int32 user_pid() const;
  void set_user_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.User_Login)
 private:
  void set_has_user_pid();
  void clear_has_user_pid();
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_password();
  void clear_has_password();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 user_pid_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsUser_LoginImpl();
};
// -------------------------------------------------------------------

class Enter_Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Enter_Channel) */ {
 public:
  Enter_Channel();
  virtual ~Enter_Channel();

  Enter_Channel(const Enter_Channel& from);

  inline Enter_Channel& operator=(const Enter_Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Enter_Channel(Enter_Channel&& from) noexcept
    : Enter_Channel() {
    *this = ::std::move(from);
  }

  inline Enter_Channel& operator=(Enter_Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Enter_Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Enter_Channel* internal_default_instance() {
    return reinterpret_cast<const Enter_Channel*>(
               &_Enter_Channel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Enter_Channel* other);
  friend void swap(Enter_Channel& a, Enter_Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Enter_Channel* New() const PROTOBUF_FINAL { return New(NULL); }

  Enter_Channel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Enter_Channel& from);
  void MergeFrom(const Enter_Channel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Enter_Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 channelIndex = 2;
  bool has_channelindex() const;
  void clear_channelindex();
  static const int kChannelIndexFieldNumber = 2;
  ::google::protobuf::int32 channelindex() const;
  void set_channelindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Enter_Channel)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_channelindex();
  void clear_has_channelindex();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 channelindex_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsEnter_ChannelImpl();
};
// -------------------------------------------------------------------

class Change_Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Change_Channel) */ {
 public:
  Change_Channel();
  virtual ~Change_Channel();

  Change_Channel(const Change_Channel& from);

  inline Change_Channel& operator=(const Change_Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Change_Channel(Change_Channel&& from) noexcept
    : Change_Channel() {
    *this = ::std::move(from);
  }

  inline Change_Channel& operator=(Change_Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Change_Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Change_Channel* internal_default_instance() {
    return reinterpret_cast<const Change_Channel*>(
               &_Change_Channel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Change_Channel* other);
  friend void swap(Change_Channel& a, Change_Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Change_Channel* New() const PROTOBUF_FINAL { return New(NULL); }

  Change_Channel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Change_Channel& from);
  void MergeFrom(const Change_Channel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Change_Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 channelIndex = 2;
  bool has_channelindex() const;
  void clear_channelindex();
  static const int kChannelIndexFieldNumber = 2;
  ::google::protobuf::int32 channelindex() const;
  void set_channelindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Change_Channel)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_channelindex();
  void clear_has_channelindex();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 channelindex_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsChange_ChannelImpl();
};
// -------------------------------------------------------------------

class Channel_Chatting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Channel_Chatting) */ {
 public:
  Channel_Chatting();
  virtual ~Channel_Chatting();

  Channel_Chatting(const Channel_Chatting& from);

  inline Channel_Chatting& operator=(const Channel_Chatting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel_Chatting(Channel_Chatting&& from) noexcept
    : Channel_Chatting() {
    *this = ::std::move(from);
  }

  inline Channel_Chatting& operator=(Channel_Chatting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel_Chatting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel_Chatting* internal_default_instance() {
    return reinterpret_cast<const Channel_Chatting*>(
               &_Channel_Chatting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Channel_Chatting* other);
  friend void swap(Channel_Chatting& a, Channel_Chatting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel_Chatting* New() const PROTOBUF_FINAL { return New(NULL); }

  Channel_Chatting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Channel_Chatting& from);
  void MergeFrom(const Channel_Chatting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Channel_Chatting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Channel_Chatting)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsChannel_ChattingImpl();
};
// -------------------------------------------------------------------

class Create_Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Create_Room) */ {
 public:
  Create_Room();
  virtual ~Create_Room();

  Create_Room(const Create_Room& from);

  inline Create_Room& operator=(const Create_Room& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Create_Room(Create_Room&& from) noexcept
    : Create_Room() {
    *this = ::std::move(from);
  }

  inline Create_Room& operator=(Create_Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Create_Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Create_Room* internal_default_instance() {
    return reinterpret_cast<const Create_Room*>(
               &_Create_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Create_Room* other);
  friend void swap(Create_Room& a, Create_Room& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Create_Room* New() const PROTOBUF_FINAL { return New(NULL); }

  Create_Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Create_Room& from);
  void MergeFrom(const Create_Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Create_Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 roomIndex = 2;
  bool has_roomindex() const;
  void clear_roomindex();
  static const int kRoomIndexFieldNumber = 2;
  ::google::protobuf::int32 roomindex() const;
  void set_roomindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Create_Room)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomindex();
  void clear_has_roomindex();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 roomindex_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsCreate_RoomImpl();
};
// -------------------------------------------------------------------

class Room_Chatting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Room_Chatting) */ {
 public:
  Room_Chatting();
  virtual ~Room_Chatting();

  Room_Chatting(const Room_Chatting& from);

  inline Room_Chatting& operator=(const Room_Chatting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Room_Chatting(Room_Chatting&& from) noexcept
    : Room_Chatting() {
    *this = ::std::move(from);
  }

  inline Room_Chatting& operator=(Room_Chatting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room_Chatting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Room_Chatting* internal_default_instance() {
    return reinterpret_cast<const Room_Chatting*>(
               &_Room_Chatting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Room_Chatting* other);
  friend void swap(Room_Chatting& a, Room_Chatting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Room_Chatting* New() const PROTOBUF_FINAL { return New(NULL); }

  Room_Chatting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Room_Chatting& from);
  void MergeFrom(const Room_Chatting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Room_Chatting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Room_Chatting)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsRoom_ChattingImpl();
};
// -------------------------------------------------------------------

class Enter_Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Enter_Room) */ {
 public:
  Enter_Room();
  virtual ~Enter_Room();

  Enter_Room(const Enter_Room& from);

  inline Enter_Room& operator=(const Enter_Room& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Enter_Room(Enter_Room&& from) noexcept
    : Enter_Room() {
    *this = ::std::move(from);
  }

  inline Enter_Room& operator=(Enter_Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Enter_Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Enter_Room* internal_default_instance() {
    return reinterpret_cast<const Enter_Room*>(
               &_Enter_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Enter_Room* other);
  friend void swap(Enter_Room& a, Enter_Room& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Enter_Room* New() const PROTOBUF_FINAL { return New(NULL); }

  Enter_Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Enter_Room& from);
  void MergeFrom(const Enter_Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Enter_Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 roomIndex = 2;
  bool has_roomindex() const;
  void clear_roomindex();
  static const int kRoomIndexFieldNumber = 2;
  ::google::protobuf::int32 roomindex() const;
  void set_roomindex(::google::protobuf::int32 value);

  // optional bool isEnter = 3;
  bool has_isenter() const;
  void clear_isenter();
  static const int kIsEnterFieldNumber = 3;
  bool isenter() const;
  void set_isenter(bool value);

  // @@protoc_insertion_point(class_scope:Protocols.Enter_Room)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomindex();
  void clear_has_roomindex();
  void set_has_isenter();
  void clear_has_isenter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 roomindex_;
  bool isenter_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsEnter_RoomImpl();
};
// -------------------------------------------------------------------

class Leave_Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Leave_Room) */ {
 public:
  Leave_Room();
  virtual ~Leave_Room();

  Leave_Room(const Leave_Room& from);

  inline Leave_Room& operator=(const Leave_Room& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Leave_Room(Leave_Room&& from) noexcept
    : Leave_Room() {
    *this = ::std::move(from);
  }

  inline Leave_Room& operator=(Leave_Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Leave_Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Leave_Room* internal_default_instance() {
    return reinterpret_cast<const Leave_Room*>(
               &_Leave_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Leave_Room* other);
  friend void swap(Leave_Room& a, Leave_Room& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Leave_Room* New() const PROTOBUF_FINAL { return New(NULL); }

  Leave_Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Leave_Room& from);
  void MergeFrom(const Leave_Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Leave_Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 roomIndex = 2;
  bool has_roomindex() const;
  void clear_roomindex();
  static const int kRoomIndexFieldNumber = 2;
  ::google::protobuf::int32 roomindex() const;
  void set_roomindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Leave_Room)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomindex();
  void clear_has_roomindex();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 roomindex_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsLeave_RoomImpl();
};
// -------------------------------------------------------------------

class Notify_Exist_Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Notify_Exist_Room) */ {
 public:
  Notify_Exist_Room();
  virtual ~Notify_Exist_Room();

  Notify_Exist_Room(const Notify_Exist_Room& from);

  inline Notify_Exist_Room& operator=(const Notify_Exist_Room& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Notify_Exist_Room(Notify_Exist_Room&& from) noexcept
    : Notify_Exist_Room() {
    *this = ::std::move(from);
  }

  inline Notify_Exist_Room& operator=(Notify_Exist_Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notify_Exist_Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notify_Exist_Room* internal_default_instance() {
    return reinterpret_cast<const Notify_Exist_Room*>(
               &_Notify_Exist_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Notify_Exist_Room* other);
  friend void swap(Notify_Exist_Room& a, Notify_Exist_Room& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Notify_Exist_Room* New() const PROTOBUF_FINAL { return New(NULL); }

  Notify_Exist_Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Notify_Exist_Room& from);
  void MergeFrom(const Notify_Exist_Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Notify_Exist_Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 roomIndex = 2;
  bool has_roomindex() const;
  void clear_roomindex();
  static const int kRoomIndexFieldNumber = 2;
  ::google::protobuf::int32 roomindex() const;
  void set_roomindex(::google::protobuf::int32 value);

  // optional bool exist = 3;
  bool has_exist() const;
  void clear_exist();
  static const int kExistFieldNumber = 3;
  bool exist() const;
  void set_exist(bool value);

  // @@protoc_insertion_point(class_scope:Protocols.Notify_Exist_Room)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomindex();
  void clear_has_roomindex();
  void set_has_exist();
  void clear_has_exist();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 roomindex_;
  bool exist_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsNotify_Exist_RoomImpl();
};
// -------------------------------------------------------------------

class Notify_Enter_Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Notify_Enter_Room) */ {
 public:
  Notify_Enter_Room();
  virtual ~Notify_Enter_Room();

  Notify_Enter_Room(const Notify_Enter_Room& from);

  inline Notify_Enter_Room& operator=(const Notify_Enter_Room& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Notify_Enter_Room(Notify_Enter_Room&& from) noexcept
    : Notify_Enter_Room() {
    *this = ::std::move(from);
  }

  inline Notify_Enter_Room& operator=(Notify_Enter_Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notify_Enter_Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notify_Enter_Room* internal_default_instance() {
    return reinterpret_cast<const Notify_Enter_Room*>(
               &_Notify_Enter_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Notify_Enter_Room* other);
  friend void swap(Notify_Enter_Room& a, Notify_Enter_Room& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Notify_Enter_Room* New() const PROTOBUF_FINAL { return New(NULL); }

  Notify_Enter_Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Notify_Enter_Room& from);
  void MergeFrom(const Notify_Enter_Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Notify_Enter_Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Notify_Enter_Room)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsNotify_Enter_RoomImpl();
};
// -------------------------------------------------------------------

class Notify_Leave_Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Notify_Leave_Room) */ {
 public:
  Notify_Leave_Room();
  virtual ~Notify_Leave_Room();

  Notify_Leave_Room(const Notify_Leave_Room& from);

  inline Notify_Leave_Room& operator=(const Notify_Leave_Room& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Notify_Leave_Room(Notify_Leave_Room&& from) noexcept
    : Notify_Leave_Room() {
    *this = ::std::move(from);
  }

  inline Notify_Leave_Room& operator=(Notify_Leave_Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notify_Leave_Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notify_Leave_Room* internal_default_instance() {
    return reinterpret_cast<const Notify_Leave_Room*>(
               &_Notify_Leave_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Notify_Leave_Room* other);
  friend void swap(Notify_Leave_Room& a, Notify_Leave_Room& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Notify_Leave_Room* New() const PROTOBUF_FINAL { return New(NULL); }

  Notify_Leave_Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Notify_Leave_Room& from);
  void MergeFrom(const Notify_Leave_Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Notify_Leave_Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Notify_Leave_Room)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsNotify_Leave_RoomImpl();
};
// -------------------------------------------------------------------

class Room_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Protocols.Room_List) */ {
 public:
  Room_List();
  virtual ~Room_List();

  Room_List(const Room_List& from);

  inline Room_List& operator=(const Room_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Room_List(Room_List&& from) noexcept
    : Room_List() {
    *this = ::std::move(from);
  }

  inline Room_List& operator=(Room_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Room_List* internal_default_instance() {
    return reinterpret_cast<const Room_List*>(
               &_Room_List_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Room_List* other);
  friend void swap(Room_List& a, Room_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Room_List* New() const PROTOBUF_FINAL { return New(NULL); }

  Room_List* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Room_List& from);
  void MergeFrom(const Room_List& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Room_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 userList = 2;
  int userlist_size() const;
  void clear_userlist();
  static const int kUserListFieldNumber = 2;
  ::google::protobuf::int32 userlist(int index) const;
  void set_userlist(int index, ::google::protobuf::int32 value);
  void add_userlist(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      userlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_userlist();

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 roomIndex = 3;
  bool has_roomindex() const;
  void clear_roomindex();
  static const int kRoomIndexFieldNumber = 3;
  ::google::protobuf::int32 roomindex() const;
  void set_roomindex(::google::protobuf::int32 value);

  // optional int32 userCount = 4;
  bool has_usercount() const;
  void clear_usercount();
  static const int kUserCountFieldNumber = 4;
  ::google::protobuf::int32 usercount() const;
  void set_usercount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocols.Room_List)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomindex();
  void clear_has_roomindex();
  void set_has_usercount();
  void clear_has_usercount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > userlist_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 roomindex_;
  ::google::protobuf::int32 usercount_;
  friend struct ::protobuf_Protocols_2eproto::TableStruct;
  friend void ::protobuf_Protocols_2eproto::InitDefaultsRoom_ListImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User_Login

// optional int32 user_pid = 1;
inline bool User_Login::has_user_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User_Login::set_has_user_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User_Login::clear_has_user_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User_Login::clear_user_pid() {
  user_pid_ = 0;
  clear_has_user_pid();
}
inline ::google::protobuf::int32 User_Login::user_pid() const {
  // @@protoc_insertion_point(field_get:Protocols.User_Login.user_pid)
  return user_pid_;
}
inline void User_Login::set_user_pid(::google::protobuf::int32 value) {
  set_has_user_pid();
  user_pid_ = value;
  // @@protoc_insertion_point(field_set:Protocols.User_Login.user_pid)
}

// optional string user_id = 2;
inline bool User_Login::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User_Login::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User_Login::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User_Login::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& User_Login::user_id() const {
  // @@protoc_insertion_point(field_get:Protocols.User_Login.user_id)
  return user_id_.GetNoArena();
}
inline void User_Login::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Protocols.User_Login.user_id)
}
#if LANG_CXX11
inline void User_Login::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Protocols.User_Login.user_id)
}
#endif
inline void User_Login::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Protocols.User_Login.user_id)
}
inline void User_Login::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Protocols.User_Login.user_id)
}
inline ::std::string* User_Login::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:Protocols.User_Login.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User_Login::release_user_id() {
  // @@protoc_insertion_point(field_release:Protocols.User_Login.user_id)
  clear_has_user_id();
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User_Login::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:Protocols.User_Login.user_id)
}

// optional string password = 3;
inline bool User_Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User_Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User_Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User_Login::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& User_Login::password() const {
  // @@protoc_insertion_point(field_get:Protocols.User_Login.password)
  return password_.GetNoArena();
}
inline void User_Login::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Protocols.User_Login.password)
}
#if LANG_CXX11
inline void User_Login::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Protocols.User_Login.password)
}
#endif
inline void User_Login::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Protocols.User_Login.password)
}
inline void User_Login::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Protocols.User_Login.password)
}
inline ::std::string* User_Login::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:Protocols.User_Login.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User_Login::release_password() {
  // @@protoc_insertion_point(field_release:Protocols.User_Login.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User_Login::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Protocols.User_Login.password)
}

// -------------------------------------------------------------------

// Enter_Channel

// optional int32 id = 1;
inline bool Enter_Channel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Enter_Channel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Enter_Channel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Enter_Channel::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Enter_Channel::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Enter_Channel.id)
  return id_;
}
inline void Enter_Channel::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Enter_Channel.id)
}

// required int32 channelIndex = 2;
inline bool Enter_Channel::has_channelindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Enter_Channel::set_has_channelindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Enter_Channel::clear_has_channelindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Enter_Channel::clear_channelindex() {
  channelindex_ = 0;
  clear_has_channelindex();
}
inline ::google::protobuf::int32 Enter_Channel::channelindex() const {
  // @@protoc_insertion_point(field_get:Protocols.Enter_Channel.channelIndex)
  return channelindex_;
}
inline void Enter_Channel::set_channelindex(::google::protobuf::int32 value) {
  set_has_channelindex();
  channelindex_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Enter_Channel.channelIndex)
}

// -------------------------------------------------------------------

// Change_Channel

// optional int32 id = 1;
inline bool Change_Channel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Change_Channel::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Change_Channel::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Change_Channel::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Change_Channel::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Change_Channel.id)
  return id_;
}
inline void Change_Channel::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Change_Channel.id)
}

// required int32 channelIndex = 2;
inline bool Change_Channel::has_channelindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Change_Channel::set_has_channelindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Change_Channel::clear_has_channelindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Change_Channel::clear_channelindex() {
  channelindex_ = 0;
  clear_has_channelindex();
}
inline ::google::protobuf::int32 Change_Channel::channelindex() const {
  // @@protoc_insertion_point(field_get:Protocols.Change_Channel.channelIndex)
  return channelindex_;
}
inline void Change_Channel::set_channelindex(::google::protobuf::int32 value) {
  set_has_channelindex();
  channelindex_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Change_Channel.channelIndex)
}

// -------------------------------------------------------------------

// Channel_Chatting

// optional int32 id = 1;
inline bool Channel_Chatting::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel_Chatting::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Channel_Chatting::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Channel_Chatting::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Channel_Chatting::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Channel_Chatting.id)
  return id_;
}
inline void Channel_Chatting::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Channel_Chatting.id)
}

// required string message = 2;
inline bool Channel_Chatting::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel_Chatting::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Channel_Chatting::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Channel_Chatting::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Channel_Chatting::message() const {
  // @@protoc_insertion_point(field_get:Protocols.Channel_Chatting.message)
  return message_.GetNoArena();
}
inline void Channel_Chatting::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Protocols.Channel_Chatting.message)
}
#if LANG_CXX11
inline void Channel_Chatting::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Protocols.Channel_Chatting.message)
}
#endif
inline void Channel_Chatting::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Protocols.Channel_Chatting.message)
}
inline void Channel_Chatting::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Protocols.Channel_Chatting.message)
}
inline ::std::string* Channel_Chatting::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:Protocols.Channel_Chatting.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel_Chatting::release_message() {
  // @@protoc_insertion_point(field_release:Protocols.Channel_Chatting.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel_Chatting::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Protocols.Channel_Chatting.message)
}

// -------------------------------------------------------------------

// Create_Room

// optional int32 id = 1;
inline bool Create_Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Create_Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Create_Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Create_Room::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Create_Room::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Create_Room.id)
  return id_;
}
inline void Create_Room::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Create_Room.id)
}

// required int32 roomIndex = 2;
inline bool Create_Room::has_roomindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Create_Room::set_has_roomindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Create_Room::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Create_Room::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 Create_Room::roomindex() const {
  // @@protoc_insertion_point(field_get:Protocols.Create_Room.roomIndex)
  return roomindex_;
}
inline void Create_Room::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Create_Room.roomIndex)
}

// -------------------------------------------------------------------

// Room_Chatting

// optional int32 id = 1;
inline bool Room_Chatting::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room_Chatting::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room_Chatting::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room_Chatting::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Room_Chatting::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Room_Chatting.id)
  return id_;
}
inline void Room_Chatting::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Room_Chatting.id)
}

// required string message = 2;
inline bool Room_Chatting::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room_Chatting::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room_Chatting::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room_Chatting::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Room_Chatting::message() const {
  // @@protoc_insertion_point(field_get:Protocols.Room_Chatting.message)
  return message_.GetNoArena();
}
inline void Room_Chatting::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Protocols.Room_Chatting.message)
}
#if LANG_CXX11
inline void Room_Chatting::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Protocols.Room_Chatting.message)
}
#endif
inline void Room_Chatting::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Protocols.Room_Chatting.message)
}
inline void Room_Chatting::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Protocols.Room_Chatting.message)
}
inline ::std::string* Room_Chatting::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:Protocols.Room_Chatting.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Room_Chatting::release_message() {
  // @@protoc_insertion_point(field_release:Protocols.Room_Chatting.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Room_Chatting::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Protocols.Room_Chatting.message)
}

// -------------------------------------------------------------------

// Enter_Room

// optional int32 id = 1;
inline bool Enter_Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Enter_Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Enter_Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Enter_Room::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Enter_Room::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Enter_Room.id)
  return id_;
}
inline void Enter_Room::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Enter_Room.id)
}

// required int32 roomIndex = 2;
inline bool Enter_Room::has_roomindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Enter_Room::set_has_roomindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Enter_Room::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Enter_Room::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 Enter_Room::roomindex() const {
  // @@protoc_insertion_point(field_get:Protocols.Enter_Room.roomIndex)
  return roomindex_;
}
inline void Enter_Room::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Enter_Room.roomIndex)
}

// optional bool isEnter = 3;
inline bool Enter_Room::has_isenter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Enter_Room::set_has_isenter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Enter_Room::clear_has_isenter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Enter_Room::clear_isenter() {
  isenter_ = false;
  clear_has_isenter();
}
inline bool Enter_Room::isenter() const {
  // @@protoc_insertion_point(field_get:Protocols.Enter_Room.isEnter)
  return isenter_;
}
inline void Enter_Room::set_isenter(bool value) {
  set_has_isenter();
  isenter_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Enter_Room.isEnter)
}

// -------------------------------------------------------------------

// Leave_Room

// optional int32 id = 1;
inline bool Leave_Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Leave_Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Leave_Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Leave_Room::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Leave_Room::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Leave_Room.id)
  return id_;
}
inline void Leave_Room::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Leave_Room.id)
}

// required int32 roomIndex = 2;
inline bool Leave_Room::has_roomindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Leave_Room::set_has_roomindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Leave_Room::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Leave_Room::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 Leave_Room::roomindex() const {
  // @@protoc_insertion_point(field_get:Protocols.Leave_Room.roomIndex)
  return roomindex_;
}
inline void Leave_Room::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Leave_Room.roomIndex)
}

// -------------------------------------------------------------------

// Notify_Exist_Room

// optional int32 id = 1;
inline bool Notify_Exist_Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notify_Exist_Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notify_Exist_Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notify_Exist_Room::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Notify_Exist_Room::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Notify_Exist_Room.id)
  return id_;
}
inline void Notify_Exist_Room::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Notify_Exist_Room.id)
}

// required int32 roomIndex = 2;
inline bool Notify_Exist_Room::has_roomindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notify_Exist_Room::set_has_roomindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notify_Exist_Room::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notify_Exist_Room::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 Notify_Exist_Room::roomindex() const {
  // @@protoc_insertion_point(field_get:Protocols.Notify_Exist_Room.roomIndex)
  return roomindex_;
}
inline void Notify_Exist_Room::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Notify_Exist_Room.roomIndex)
}

// optional bool exist = 3;
inline bool Notify_Exist_Room::has_exist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notify_Exist_Room::set_has_exist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notify_Exist_Room::clear_has_exist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notify_Exist_Room::clear_exist() {
  exist_ = false;
  clear_has_exist();
}
inline bool Notify_Exist_Room::exist() const {
  // @@protoc_insertion_point(field_get:Protocols.Notify_Exist_Room.exist)
  return exist_;
}
inline void Notify_Exist_Room::set_exist(bool value) {
  set_has_exist();
  exist_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Notify_Exist_Room.exist)
}

// -------------------------------------------------------------------

// Notify_Enter_Room

// optional int32 id = 1;
inline bool Notify_Enter_Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notify_Enter_Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notify_Enter_Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notify_Enter_Room::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Notify_Enter_Room::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Notify_Enter_Room.id)
  return id_;
}
inline void Notify_Enter_Room::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Notify_Enter_Room.id)
}

// -------------------------------------------------------------------

// Notify_Leave_Room

// optional int32 id = 1;
inline bool Notify_Leave_Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notify_Leave_Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notify_Leave_Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notify_Leave_Room::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Notify_Leave_Room::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Notify_Leave_Room.id)
  return id_;
}
inline void Notify_Leave_Room::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Notify_Leave_Room.id)
}

// -------------------------------------------------------------------

// Room_List

// optional int32 id = 1;
inline bool Room_List::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room_List::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room_List::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room_List::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Room_List::id() const {
  // @@protoc_insertion_point(field_get:Protocols.Room_List.id)
  return id_;
}
inline void Room_List::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Room_List.id)
}

// repeated int32 userList = 2;
inline int Room_List::userlist_size() const {
  return userlist_.size();
}
inline void Room_List::clear_userlist() {
  userlist_.Clear();
}
inline ::google::protobuf::int32 Room_List::userlist(int index) const {
  // @@protoc_insertion_point(field_get:Protocols.Room_List.userList)
  return userlist_.Get(index);
}
inline void Room_List::set_userlist(int index, ::google::protobuf::int32 value) {
  userlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocols.Room_List.userList)
}
inline void Room_List::add_userlist(::google::protobuf::int32 value) {
  userlist_.Add(value);
  // @@protoc_insertion_point(field_add:Protocols.Room_List.userList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Room_List::userlist() const {
  // @@protoc_insertion_point(field_list:Protocols.Room_List.userList)
  return userlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Room_List::mutable_userlist() {
  // @@protoc_insertion_point(field_mutable_list:Protocols.Room_List.userList)
  return &userlist_;
}

// required int32 roomIndex = 3;
inline bool Room_List::has_roomindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room_List::set_has_roomindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room_List::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room_List::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 Room_List::roomindex() const {
  // @@protoc_insertion_point(field_get:Protocols.Room_List.roomIndex)
  return roomindex_;
}
inline void Room_List::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Room_List.roomIndex)
}

// optional int32 userCount = 4;
inline bool Room_List::has_usercount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room_List::set_has_usercount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room_List::clear_has_usercount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room_List::clear_usercount() {
  usercount_ = 0;
  clear_has_usercount();
}
inline ::google::protobuf::int32 Room_List::usercount() const {
  // @@protoc_insertion_point(field_get:Protocols.Room_List.userCount)
  return usercount_;
}
inline void Room_List::set_usercount(::google::protobuf::int32 value) {
  set_has_usercount();
  usercount_ = value;
  // @@protoc_insertion_point(field_set:Protocols.Room_List.userCount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocols

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Protocols::PacketType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocols::PacketType>() {
  return ::Protocols::PacketType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Protocols_2eproto__INCLUDED
